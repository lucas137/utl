/*
Licensed under the MIT License <http://opensource.org/licenses/MIT>

Copyright 2016 Nathan Lucas <nathan.lucas@wayne.edu>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
//===========================================================================//
/// @file
/// @brief    Compile-time utilities.
/// @author   Nathan Lucas
/// @date     2016-2017
//===========================================================================//
#ifndef UTL_COMPILE_HPP
#define UTL_COMPILE_HPP

#ifndef __cplusplus
#error must be compiled as C++
#endif

/*
  16.8 Predefined macro names [cpp.predefined]
  The following macro names shall be defined by the implementation:
  __LINE__  The line number of the current source line (a decimal constant).
  __FILE__  The presumed name of the source file (a character string literal).
  __DATE__  The date of translation of the source file (a character string
            literal of the form "Mmm dd yyyy", where the names of the months
            are the same as those generated by the asctime function, and the
            first character of dd is a space character if the value is less
            than 10). If the date of translation is not available, an
            implementation-defined valid date is supplied.
  __TIME__  The time of translation of the source file (a character string
            literal of the form "hh:mm:ss" as in the time generated by the
            asctime function). If the time of translation is not available,
            an implementation-defined valid time is supplied.
  __STDC__  Whether __STDC__ is predefined and if so, what its value is, are implementation-defined.
  __cplusplus   Defined to the value 199711L when compiling a C++ translation unit.
*/

#include <string>   // std::string

/**
  @defgroup utl_compile   compile
  @brief    Source code compilation utilities.
  @details  Header-only library providing compile-time utilities.
*/

/**
  @namespace  utl::compile
  @brief  Compile-time utilities.
*/
namespace utl { namespace compile {

/// @addtogroup utl_compile
/// @{

//---------------------------------------------------------------------------
/// @name Source file information
/// @{

/// @brief  Inner-most macro enabling SOURCE_LINE.
#define SOURCE_LINE_2(x) #x

/// @brief  Middle macro enabling SOURCE_LINE.
#define SOURCE_LINE_1(x) SOURCE_LINE_2(x)

/**
  @brief  Source file name and line number, separated by a colon (`:`).

  Usage:
  ```
  std::cout << SOURCE_LINE;
  ```
  Possible output:

      D:\Lucas\projects\utl\utl\compile.hpp:44
*/
#define SOURCE_LINE __FILE__ ":" SOURCE_LINE_1(__LINE__)

/// @}
//---------------------------------------------------------------------------

namespace detail {
constexpr char const time_hh_[]   = { __TIME__[0], __TIME__[1], '\0' };
constexpr char const time_mm_[]   = { __TIME__[3], __TIME__[4], '\0' };
constexpr char const time_ss_[]   = { __TIME__[6], __TIME__[7], '\0' };
constexpr char const date_d_[]    = {              __DATE__[5], '\0' };
constexpr char const date_0d_[]   = {         '0', __DATE__[5], '\0' };
constexpr char const date_dd_[]   = { __DATE__[4], __DATE__[5], '\0' };
constexpr char const date_mmm_[]  = { __DATE__[0], __DATE__[1],
                                      __DATE__[2], '\0' };
constexpr char const date_yy_[]   = { __DATE__[9], __DATE__[10], '\0' };
constexpr char const date_yyyy_[] = { __DATE__[7], __DATE__[8],
                                      __DATE__[9], __DATE__[10], '\0' };
}

//---------------------------------------------------------------------------
/// @name Date of source file translation
/// @{

// __DATE__ example: "Jul 22 2016"
//                    01234567890

//constexpr bool is_month(char const Mmm[4]) { return (month_Mmm == Mmm); }

// __DATE__ contains 11 characters and looks like "Feb 12 1996"

//-----------------------------------------------------------
// Day

/// Returns a numeric value of the compilation
/// day of the month (e.g., `7`, `29`).
static constexpr unsigned
date_d()
{
  return ((__DATE__[4] == ' ' ? 0 : __DATE__[4] - '0') * 10 +
                                   (__DATE__[5] - '0'));
}

/// Returns a 1- or 2-character string literal containing
/// compilation day of the month (e.g., `"7"`, `"29"`).
static constexpr char const*
date_d_str()
{
  return (__DATE__[4] == ' ' ? detail::date_d_ : detail::date_dd_);
}

/// Returns a 2-character string literal containing
/// compilation day of the month (e.g., `"07"`, `"29"`).
static constexpr char const*
date_dd_str()
{
  return (__DATE__[4] == ' ' ? detail::date_0d_ : detail::date_dd_);
}

//-----------------------------------------------------------
// Month

/// Returns a numeric value of the compilation month (e.g., `3`, `10`).
static constexpr unsigned
date_m()
{
  return ((__DATE__[2] == 'n') ? (__DATE__[1] == 'a' ? 1 : 6)   // Jan Jun
        : (__DATE__[2] == 'b') ? 2                              // Feb
        : (__DATE__[2] == 'r') ? (__DATE__[1] == 'a' ? 3 : 4)   // Mar Apr
        : (__DATE__[2] == 'y') ? 5                              // May
        : (__DATE__[2] == 'l') ? 7                              // Jul
        : (__DATE__[2] == 'g') ? 8                              // Aug
        : (__DATE__[2] == 'p') ? 9                              // Sep
        : (__DATE__[2] == 't') ? 10                             // Oct
        : (__DATE__[2] == 'v') ? 11                             // Nov
        : /* default */          12);                           // Dec
}

/// Returns a 1- or 2-character string literal containing
/// compilation month (e.g., `"3"`, `"10"`).
static constexpr char const*
date_m_str()
{
  return ((__DATE__[2] == 'n') ? (__DATE__[1] == 'a' ? "1" : "6")   // Jan Jun
        : (__DATE__[2] == 'b') ? "2"                                // Feb
        : (__DATE__[2] == 'r') ? (__DATE__[1] == 'a' ? "3" : "4")   // Mar Apr
        : (__DATE__[2] == 'y') ? "5"                                // May
        : (__DATE__[2] == 'l') ? "7"                                // Jul
        : (__DATE__[2] == 'g') ? "8"                                // Aug
        : (__DATE__[2] == 'p') ? "9"                                // Sep
        : (__DATE__[2] == 't') ? "10"                               // Oct
        : (__DATE__[2] == 'v') ? "11"                               // Nov
        : /* default */          "12");                             // Dec
}

/// Returns 2-character string literal containing
/// compilation month (e.g., `"03"`, `"10"`).
static constexpr char const*
date_mm_str()
{
  return ((__DATE__[2] == 'n') ? (__DATE__[1] == 'a' ? "01" : "06") // Jan Jun
        : (__DATE__[2] == 'b') ? "02"                               // Feb
        : (__DATE__[2] == 'r') ? (__DATE__[1] == 'a' ? "03" : "04") // Mar Apr
        : (__DATE__[2] == 'y') ? "05"                               // May
        : (__DATE__[2] == 'l') ? "07"                               // Jul
        : (__DATE__[2] == 'g') ? "08"                               // Aug
        : (__DATE__[2] == 'p') ? "09"                               // Sep
        : (__DATE__[2] == 't') ? "10"                               // Oct
        : (__DATE__[2] == 'v') ? "11"                               // Nov
        : /* default */          "12");                             // Dec
}

/// Returns 3-character string literal containing
/// compilation month (e.g., `"Mar"`, `"Oct"`).
static constexpr char const*
date_mmm_str()
{
  return detail::date_mmm_;
}

//-----------------------------------------------------------
// Year

/// Returns a numeric value containing the
/// 2-digit compilation year (e.g., `17`).
constexpr unsigned
date_yy()
{
  return (((__DATE__[9]  - '0')) * 10 +
           (__DATE__[10] - '0'));
}

/// Returns a number containing the
/// 4-digit compilation year (e.g., `2017`).
constexpr unsigned
date_yyyy()
{
  return ((((__DATE__[7]  - '0') * 10 +
            (__DATE__[8]  - '0')) * 10 +
            (__DATE__[9]  - '0')) * 10 +
            (__DATE__[10] - '0'));
}

/// Returns a string literal containing the 2-digit
/// compilation year (e.g., `"00"`, `"17"`).
static constexpr char const*
date_yy_str()
{
  return detail::date_yy_;
}

/// Returns a string literal containing the 4-digit
/// compilation year (e.g., `"2000"`, `"2017"`).
static constexpr char const*
date_yyyy_str()
{
  return detail::date_yyyy_;
}

//-----------------------------------------------------------
// Year, month, day

/// Returns a number containing the 8-digit compilation
/// date is ISO 8601 basic format (e.g., `20170917`).
constexpr unsigned
date_yyyymmdd()
{
  return ((date_yyyy() * 100 +
           date_m())   * 100 +
           date_d());
}

/// Returns a string literal containing the compilation
/// date (e.g., `"20160312"`, `"2016-03-12"`)
inline std::string
date_yyyymmdd_str(std::string const& delim="")
{
  return date_yyyy_str() + delim + date_mm_str() + delim + date_dd_str();
}

/// @}
//---------------------------------------------------------------------------
/// @name Time of source file translation
/// @{

// Example of __TIME__ string: "09:30:15"
//                              01234567

//-----------------------------------------------------------
// Hour

/// Returns a numeric value containing the
/// compilation time hour (e.g., `9`, `12`).
constexpr unsigned
time_hh()
{
  return (((__TIME__[0] - '0')) * 10 +
           (__TIME__[1] - '0'));
}

/// Returns a string literal containing the 2-digit
/// compilation time hour (e.g., `"09"`, `"12"`).
static constexpr char const*
time_hh_str()
{
  return detail::time_hh_;
}

//-----------------------------------------------------------
// Minutes

/// Returns a numeric value containing the
/// compilation time minute (e.g., `5`, `30`).
constexpr unsigned
time_mm()
{
  return (((__TIME__[3] - '0')) * 10 +
           (__TIME__[4] - '0'));
}

/// Returns a string literal containing the 2-digit
/// compilation time minutes (e.g., `"30"`).
static constexpr char const*
time_mm_str()
{
  return detail::time_mm_;
}

//-----------------------------------------------------------
// Seconds

/// Returns a numeric value containing the
/// compilation time seconds (e.g., `7`, `15`).
constexpr unsigned
time_ss()
{
  return ((__TIME__[6] - '0') * 10 +
          (__TIME__[7] - '0'));
}

/// Returns a string literal containing the 2-digit
/// compilation time seconds (e.g., `"07"`, `"15"`).
static constexpr char const*
time_ss_str()
{
  return detail::time_ss_;
}

//-----------------------------------------------------------
// Hour, minutes, seconds

/// Returns a number containing the 8-digit compilation
/// date is ISO 8601 basic format (i.e., `hhmmss`).
constexpr unsigned
time_hhmmss()
{
  return ((((((__TIME__[0] - '0') * 10 +
              (__TIME__[1] - '0')) * 10 +
              (__TIME__[3] - '0')) * 10 +
              (__TIME__[4] - '0')) * 10 +
              (__TIME__[6] - '0')) * 10 +
              (__TIME__[7] - '0'));
}

/// Returns a string containing the time
/// of compilation (e.g., `"hhmmss"`, `"hh:mm:ss"`).
inline std::string
time_hhmmss_str(std::string const& delim="")
{
  return detail::time_hh_ + delim +
         detail::time_mm_ + delim +
         detail::time_ss_;
}

/// @}
//---------------------------------------------------------------------------

/// @}
} } // utl::compile

#endif // UTL_COMPILE_HPP
//===========================================================================//
